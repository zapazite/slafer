# Trying to make a basic tokenizer in BQN.

# Here is BQN tokenizer function from BQN compiler by Marshall Lochbaum.



# Source to âŸ¨tokens, roles, number of identifiers, literalsâŸ©
# Identifiers then literal tokens are numbered starting at vi

Tokenizeâ†{Systemâ€¿varsâ†ğ•¨
  # Resolve comments and strings
  câ†ğ•©='#'â‹„sâ†/0â€¿0âŠ¸Â«âŠ¸âˆ§smâ†ğ•©='''â‹„dâ†/dmâ†ğ•©='"'
  gâ†â‹qâ†âˆ¾âŸ¨  sâ‹„Â¯1â†“dâ‹„/câŸ© â‹„qâ†©gâŠq                # Open indices
  eâ† gâŠâˆ¾âŸ¨2+sâ‹„ 1â†“dâ‹„-âŸœÂ»âˆ˜âŠâŸœ(0âˆ¾+`c)âŠ¸//(ğ•©âˆŠlf)âˆ¾1âŸ© # Matching close indices
  Seâ†â‰ (>/âŠ¢)âˆ¾âŸœâ‰ {(âŠËœğ•¨)ğ•ŠâŸ(â‰ â—‹(Â¯1âŠ¸âŠ‘))ğ•©âˆ¾ğ•©âŠğ•¨}âŸ¨0âŸ©Ë™  # Find reachable openings
  Stâ†(â‰ ğ•©)â†‘Â·/â¼(Se qâ‹e)âŠ¸âŠ                     # All indices â†’ reached mask
  aâ†St qâ‹„bâ†St eâ‹„fâ†1â‰ `abâ†aâˆ¨b                 # Open/close masks; filter
  {!âŸ¨âŠ‘/ğ•©,"Unclosed quote"âŸ©}âŸ(âˆ¨Â´)(smâˆ¨dm)âˆ§b<f

  # Extract character and string literals
  uâ†fâˆ§ğ•©='@'â‹„ciâ†/uâˆ¨Â»aâˆ§sm
  chrâ†(âŠâŸœğ•©-('@'-@)Ã—âŠâŸœu)ci                   # Characters (indices ci)
  f>â†©qeâ†dmâˆ§Â«aâˆ§â†©dm                           # Quote Escape ""
  strâ†ğ•©âŠ”Ëœ1-Ëœ(siâ†a>Â»qe)(âŠ£+`âŠ¸Ã—â—‹(âˆ¾âŸœ1)<)â‰ `dmâˆ§ab # Strings (indices /si)

  # Extract words: identifiers and numbers
  ieâ†/fâ‹„isâ†ieâ‰ âŠ¸â†‘/1Â»f                        # Token start and end
  is-â†©is(-Ã—âŠâŸœc)ie                           # Comment â†’ ending newline only
  tâ†CharCode ieâŠğ•©
  ndâ†(t=âŠ‘bN)>Â«t M bDâ‹„rrâ†t=bR                # Namespace dot; ğ•£
  wâ†Â»âŠ¸<lâ†rrâˆ¨nd<t M bN(âŠ£â‹ˆ-Ëœ)â—‹âŠ‘bW             # Word chars l, start w
  usâ†t=Â¯1++Â´bAâ‹„syâ†t=âŠ‘bW                     # Underscore, system dot
  {!âŸ¨is/Ëœusâˆ§w+`âŠ¸âŠ0âˆ¾ğ•©,"Words can't only have underscores"âŸ©}âŸ(âˆ¨Â´)w(/<1(âŠ¢/Â«)(âˆ¨/âŠ£))l>us
  wkâ†(Â¬w/rr)Ã—naâŒŠâˆ˜Ã·Ëœ(âŠ‘bA)-Ëœw/t               # Kind of word from first char
  t-â†©naÃ—lâˆ§tâ‰¥na+âŠ‘bA                          # Case-insensitive
  {!âŸ¨ğ•©/is,"System dot with no name"âŸ©}âŸ(âˆ¨Â´)sy>Â«l
  wâ‰ â†©Â»âŠ¸âˆ¨sy                                  # Start system word at dot
  wiâ†0<wtâ†(2Ã—wkâ‰¥0)(Ã—âŸœÂ¬+âŠ¢)w/sy               # Type: 0 number, 1 system, 2 identifier
  iâ†l>nâ†lâˆ§(+`w)âŠ0âˆ¾Â¬wi                       # Identifier/Number masks
  numâ†is ReadNumsâ—‹(((0âˆ¾us)<âˆ¨âŸœÂ«0âˆ¾n)/0âŠ¸âˆ¾) tÃ—l # Numbers
  irâ†(us/ËœÂ«âŠ¸<i)(âŠ¢+âˆ§âŸœ(2âŠ¸=))wi/wk             # Identifier role
  ifâ†(Â»âŒˆ`)âŠ¸<igâ†(i>us)Ã—+`w>n                 # Identifier groups and first character
  frâ†(1=wi/wt)<if/rr                        # Identifier is ğ•£-based
  wâ†©ifâˆ¨nâˆ§w0â†wâ‹„wsâ†1=0âŠ¸<âŠ¸/wt/Ëœâ†©Â¬w/rr          # Don't produce an identifier for ğ•£
  {!âŸ¨ğ•©/is,"ğ•£ can't be used with other word characters"âŸ©}âŸ(âˆ¨Â´)(i>us)âˆ§(rrâŠ¸â‰ âˆ¨ifâŠ¸<)igâŠ0âˆ¾fr
  {!âŸ¨isâŠËœğ•©/ğ•¨,"Numbers can't start with underscores"âŸ©}âŸ(âˆ¨Â´âŠ¢)âŸœ(ws<(âŠ‘bA)>âŠâŸœt)/rr<if
  igâŠâ†©1-Ëœ0âˆ¾+`âŠ¸Ã—Â¬fr
  idâ†varsâŠ¸âˆ¾âŒ¾âŠ‘(wsâˆ¾2)âŠ”igâŠ”tâŠcharSet            # âŸ¨Identifiers, system valuesâŸ©

  # Deduplicate literals and identifiers; other cleanup
  kiâ†(wtâ’âŠ¸âŠ/w>rr)âˆ¾(ciâˆ¾/si)âŠ+`Â»f             # Indices in t
  kâ†idâˆ¾numâ€¿chrâ€¿strâ‹„k(âŠ¢>Â¯1Â»âŒˆ`)âŠ¸/Â¨Ëœâ†©jâ†âŠÂ¨k     # IDs j into uniques k
  kâ†©SystemâŒ¾(1âŠ¸âŠ‘)k                           # System value lookup
  wfâ†Â¬lâˆ¨t M bWâ‹„is/Ëœâ†©wfâˆ¨w0â‹„ie/Ëœâ†©wfâˆ¨>âŸœÂ«l      # Index management for...
  tâ†©(wâˆ¨wf)/(varsâ‰ âŠ¸â†“âˆ¾j++`vdÂ»kkâ†â‰ Â¨k)âŒ¾(kiâŠ¸âŠ)t  # Add IDs; remove words/whitespace
  t-â†©t(MÃ—-âŸœâŠ‘)bS                             # Separators are equivalent
  pâ†â‰ `1Â¨sbâ†Â¯1â†“1â†“/1(âˆ¾â‰ âˆ¾Ëœ)t=sep               # Separator group boundaries (excludes leading and trailing)
  ebâ†3â€¿5â€¿7+âŠ‘bB                              # End brackets that allow separators
  skâ†sb/Ëœp>âˆ¨âŸœÂ«(MâŸœbHâˆ¨ebâˆŠËœpâŠ¸+)(sb-p)âŠt        # Keep the first of each group that's not just inside a bracket
  t{is/Ëœâ†©ğ•¨â‹„ie/Ëœâ†©ğ•¨â‹„ğ•¨/ğ•©}Ëœâ†©1Â¨âŒ¾(skâŠ¸âŠ)tâ‰ sep      # Remove the rest
  imâ†(t=bR)âˆ¨t M vdâ‹ˆ+Â´2â†‘kk                   # Identifier (or ğ•£) mask
  râ†irâŒ¾(imâŠ¸/)(vdâŒŠt)âŠcharRoleâˆ¾0              # Role
  t+â†©(âŠ‘bX)((âŠ¢Mâ‹ˆâŸœ5)Ã—5+3âŠ¸+âŠ¸â‰¤)t                # Case-insensitive special names
  t-â†©vi(<+10Ã—=)t                            # Shift . to bX and variables back one
  âŸ¨t,r,k,is,ieâŸ©
}
